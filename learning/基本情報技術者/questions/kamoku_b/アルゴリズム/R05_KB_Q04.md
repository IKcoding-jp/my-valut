---
id: R05_KB_Q04
year: R05
kamoku: B
number: 4
type: アルゴリズム
subtopic: ハッシュ表
difficulty: 3
status: 未学習
last_attempt: null
confidence_history: []
result_history: []
time_spent_seconds: []
---

## 問題

次の記述中の ＿＿ に入れる正しい答えを、解答群の中から選べ。ここで、配列の要素番号は1から始まる。

関数 `add` は、引数で指定された正の整数 `value` を大域の整数型の配列 `hashArray` に格納する。格納できた場合は `true` を返し、格納できなかった場合は `false` を返す。関数 `calcHash1` 及び関数 `calcHash2` を利用して格納位置を決める。

配列 `hashArray` の要素数は5で、全要素が `-1` で初期化されているとする。手続 `test` を実行した後の `hashArray` の内容は ＿＿ である。

```
○整数型: calcHash1(整数型: value)
  return (value mod hashArrayの要素数) + 1

○整数型: calcHash2(整数型: value)
  return ((value + 3) mod hashArrayの要素数) + 1

○論理型: add(整数型: value)
  整数型: hash
  hash ← calcHash1(value)
  if (hashArray[hash] ≠ -1)
    hash ← calcHash2(value)
    if (hashArray[hash] ≠ -1)
      return false
    endif
  endif
  hashArray[hash] ← value
  return true

○test()
  add(3)
  add(18)
  add(11)
```

## 選択肢
- ア: {-1, 3, -1, 18, 11}
- イ: {-1, 11, -1, 3, -1}
- ウ: {-1, 11, -1, 18, -1}
- エ: {-1, 18, -1, 3, 11}
- オ: {-1, 18, 11, 3, -1}

## 正解
エ

## 解説

### ハッシュ関数の計算

配列サイズ = 5

- `calcHash1(value)` = `(value mod 5) + 1`
- `calcHash2(value)` = `((value + 3) mod 5) + 1`

### トレース過程

**初期状態**: hashArray = {-1, -1, -1, -1, -1}

**add(3)**:
1. `calcHash1(3)` = `(3 mod 5) + 1` = `3 + 1` = **4**
2. `hashArray[4]` は `-1`（空き） → 衝突なし
3. `hashArray[4] ← 3`
4. 結果: hashArray = {-1, -1, -1, **3**, -1}

**add(18)**:
1. `calcHash1(18)` = `(18 mod 5) + 1` = `3 + 1` = **4**
2. `hashArray[4]` は `3`（-1でない） → 衝突！
3. `calcHash2(18)` = `((18 + 3) mod 5) + 1` = `(21 mod 5) + 1` = `1 + 1` = **2**
4. `hashArray[2]` は `-1`（空き） → 格納可能
5. `hashArray[2] ← 18`
6. 結果: hashArray = {-1, **18**, -1, 3, -1}

**add(11)**:
1. `calcHash1(11)` = `(11 mod 5) + 1` = `1 + 1` = **2**
2. `hashArray[2]` は `18`（-1でない） → 衝突！
3. `calcHash2(11)` = `((11 + 3) mod 5) + 1` = `(14 mod 5) + 1` = `4 + 1` = **5**
4. `hashArray[5]` は `-1`（空き） → 格納可能
5. `hashArray[5] ← 11`
6. 結果: hashArray = {-1, 18, -1, 3, **11**}

### 最終結果

hashArray = {-1, 18, -1, 3, 11} → **エ** が正解

### アルゴリズムのポイント
- **ハッシュ法**: 値からハッシュ関数で格納位置を計算する方法
- **衝突（コリジョン）**: 異なる値が同じ位置に格納されようとすること
- **オープンアドレス法**: 衝突時に別のハッシュ関数で新しい位置を探す方法（この問題のアプローチ）
- mod（剰余）計算を正確に行い、1ステップずつトレースすることが重要
- 格納順序が結果に影響するため、add の呼び出し順に注意する
