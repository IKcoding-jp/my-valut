---
id: R05_KB_Q04
year: R05
kamoku: B
number: 4
type: アルゴリズム
subtopic: スタック操作
difficulty: 3
status: 未学習
last_attempt: null
confidence_history: []
result_history: []
time_spent_seconds: []
---

## 問題

次のプログラムは、文字列 `str` の各文字を順に読み取り、スタックを使って処理を行う。文字列 `str` が `"AB+CD*"` のとき、プログラム終了時のスタックの状態として正しいものはどれか。

ただし、スタックの初期状態は空であり、`push(x)` はスタックの一番上に `x` を積む操作、`pop()` はスタックの一番上から要素を取り出す操作である。

```
○processString(文字型の配列: str)
  文字型: ch, op1, op2
  整数型: i
  for (i を 0 から str の文字数 - 1 まで 1 ずつ増やす)
    ch ← str[i]
    if (ch ≠ '*' かつ ch ≠ '+')
      push(ch)
    else
      op1 ← pop()
      op2 ← pop()
      push(ch)
    endif
  endfor
```

## 選択肢
- ア: スタック（底から）: [*, +]
- イ: スタック（底から）: [+, *]
- ウ: スタック（底から）: [*, *, +]
- エ: スタック（底から）: [+, +, *]

## 正解
イ

## 解説

### トレース過程

文字列 `str = "AB+CD*"`、スタック初期状態: （空）

| i | ch | 条件判定 | 操作 | スタック（底→上） |
|---|-----|----------|------|-------------------|
| 0 | A | A は * でも + でもない | push('A') | [A] |
| 1 | B | B は * でも + でもない | push('B') | [A, B] |
| 2 | + | + である | op1←pop()→B, op2←pop()→A, push('+') | [+] |
| 3 | C | C は * でも + でもない | push('C') | [+, C] |
| 4 | D | D は * でも + でもない | push('D') | [+, C, D] |
| 5 | * | * である | op1←pop()→D, op2←pop()→C, push('*') | [+, *] |

最終状態: スタック = [+, *]（底から順に `+`、`*`）

### 正解の理由

トレースの結果、スタックには底から `+`、`*` の順で2つの要素が残る。よって正解は **イ** である。

このプログラムは逆ポーランド記法（後置記法）の処理を模している。通常の数式 `(A+B)*(C*D)` のような計算をスタックで処理する仕組みの基本形である。

### アルゴリズムのポイント
- スタックは「後入れ先出し（LIFO）」の構造。最後に入れたものが最初に出てくる
- push と pop の操作を1ステップずつ丁寧にトレースすることが最も確実な解法
- 演算子に出会うと「2つ取り出して1つ積む」ので、要素数が1つ減る
- 最終的にスタックに残る要素数 = 文字の数 - 演算子の数（この問題では 4 - 2 = 2）
- トレース表を書いて「今スタックに何が入っているか」を常に把握する

### 類似パターン
- [[キュー操作]]（FIFO: 先入れ先出しとの違いを理解する）
- [[逆ポーランド記法の計算]]（数値を使った実際の計算問題）
